apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'war'
apply plugin: 'com.bmuschko.docker-remote-api'

import com.bmuschko.gradle.docker.tasks.container.*
import com.bmuschko.gradle.docker.tasks.image.*

sourceCompatibility = 1.8

buildscript {
    repositories {
        jcenter()
    }

    dependencies {
        classpath 'com.bmuschko:gradle-docker-plugin:3.2.6'
    }
}

repositories {
    mavenCentral()
    jcenter()
}


dependencies {
    testCompile("junit:junit:4.12")
    testCompile("org.mockito:mockito-core:2.7.19")
    //I don't think this is necessary but if something breaks with tests down the line, probably should have it in
    //testCompile("com.lemmingapex.trilateration:trilateration:1.0.2")
    compile("com.lemmingapex.trilateration:trilateration:1.0.2")
    compile("com.google.code.gson:gson:2.8.2")
    compile("mysql:mysql-connector-java:5.1.6")
    providedCompile 'javax.servlet:javax.servlet-api:3.1.0'
}

task createDockerfile(type: Dockerfile) {
    destFile = project.file("build/docker/Dockerfile")
    from "tomcat:9-jre8"
    //copyFile("tomcatconf/tomcat-users.xml", "/usr/local/tomcat/conf/")
}

task buildDockerImage(type: DockerBuildImage) {
    dependsOn createDockerfile
    inputDir = createDockerfile.destFile.parentFile
    tag = "rocate/rocate"
}

task createDBContainer(type: DockerCreateContainer) {
    targetImageId {"mysql:latest"}
    containerName = "rocate_db"
    env = ["MYSQL_DATABASE=rocate", "MYSQL_ROOT_PASSWORD=hellorocate", "MYSQL_USER=rocate", "MYSQL_PASSWORD=rocate123"]
}

task createDockerContainer(type: DockerCreateContainer) {
    dependsOn = [buildDockerImage, createDBContainer]
    targetImageId {buildDockerImage.getImageId()}
    portBindings = ['8888:8080']

    doFirst {
        links = ["${createDBContainer.getContainerId()}:database"]
    }
}

task dockerDeploy(type: DockerCopyFileToContainer) {
    dependsOn = [war, createDockerContainer]
    targetContainerId {createDockerContainer.getContainerId()}
    hostPath = project.file("build/libs/${rootProject.name}.war")
    remotePath = "/usr/local/tomcat/webapps/"
}

task startDBContainer(type: DockerStartContainer) {
    dependsOn createDBContainer
    targetContainerId {createDBContainer.getContainerId()}

    doLast {
        project.file("build/docker/runningDBContainer.txt").text = """${createDBContainer.getContainerId()}"""
    }
}

task startDockerContainer(type: DockerStartContainer) {
    dependsOn = [dockerDeploy, createDockerContainer, startDBContainer]
    targetContainerId {createDockerContainer.getContainerId()}

    doLast {
        project.file("build/docker/runningAppContainer.txt").text = """${createDockerContainer.getContainerId()}"""
    }
}

task stopDockerContainer(type: DockerStopContainer) {
    /*
    So the flow is a bit convoluted here (maybe could be cleaned up) but it goes like this
    1. Stop app container
    2. internalContainerCleanup -> internalCleanupDBContainer -> stopDBContainer
    3. Stop DB container
    4. internalCleanupAppContainer
    5. internalDeleteContainerId
     */
    targetContainerId { project.file("build/docker/runningAppContainer.txt").text }
    finalizedBy {internalContainerCleanup}
}

task internalContainerCleanup() {
    dependsOn {internalCleanupDBContainer}
    finalizedBy {internalCleanupAppContainer}
}

task stopDBContainer(type: DockerStopContainer) {
    targetContainerId {project.file("build/docker/runningDBContainer.txt").text}
}

task internalCleanupAppContainer(type: DockerRemoveContainer) {
    targetContainerId { project.file("build/docker/runningAppContainer.txt").text }
    finalizedBy {internalDeleteContainerId}
}

task internalCleanupDBContainer(type: DockerRemoveContainer) {
    dependsOn {stopDBContainer}
    targetContainerId { project.file("build/docker/runningDBContainer.txt").text }
}

task internalDeleteContainerId(type: Delete) {
    delete "build/docker/runningAppContainer.txt"
    delete "build/docker/runningDBContainer.txt"
}
